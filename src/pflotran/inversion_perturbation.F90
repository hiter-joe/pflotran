module Inversion_Perturbation_class

#include "petsc/finclude/petscksp.h"
  use petscksp

  use PFLOTRAN_Constants_module
  use Inversion_Base_class
  use Inversion_Subsurface_class

  implicit none

  private

  type, public, extends(inversion_subsurface_type) :: &
                                            inversion_perturbation_type
    Vec :: quantity_of_interest_base
    Vec :: base_measurement_vec
    PetscInt :: ndof
    PetscInt :: idof_pert
    PetscReal :: pert
    PetscReal :: perturbation_tolerance
    PetscInt, pointer :: select_cells(:)

    PetscInt :: start_iteration          ! Starting iteration number
    PetscInt :: miniter,maxiter          ! min/max CGLS iterations

    PetscReal :: beta                    ! regularization parameter
    PetscReal :: beta_red_factor         ! beta reduction factor
    PetscReal :: minperm,maxperm         ! min/max permeability
    PetscReal :: target_chi2             ! target CHI^2 norm
    PetscReal :: current_chi2

    ! Cost/objective functions
    PetscReal :: min_phi_red             ! min change in cost function
    PetscReal :: phi_total_0,phi_total
    PetscReal :: phi_data_0,phi_data
    PetscReal :: phi_model_0,phi_model

    ! arrays for CGLS algorithm
    PetscReal, pointer :: b(:)           ! vector for CGLS RHS
    PetscReal, pointer :: p(:)           ! vector of dim -> num of inv cells
    PetscReal, pointer :: q(:)           ! product of Jacobian with p = Jp
    PetscReal, pointer :: r(:)           ! vector of dim -> num of measur
    PetscReal, pointer :: s(:)           ! product Jacobian transpose with r
    PetscReal, pointer :: del_perm(:)    ! permeability update vector

    ! For Wm
    PetscInt :: num_constraints_local    ! Number of constraints
    PetscInt :: num_constraints_total    ! Total number of constraints
    PetscInt, pointer :: rblock(:,:)     ! array stores info about reg.
    PetscReal, pointer :: Wm(:)          ! Regularization matrix
    Vec :: natural_vec

    type(constrained_block_type), pointer :: constrained_block

  contains
    procedure, public :: Init => InversionPerturbationInit
    procedure, public :: ReadBlock => InversionPerturbationReadBlock
    procedure, public :: Initialize => InversionPerturbationInitialize
    procedure, public :: Step => InversionPerturbationStep
    procedure, public :: UpdateParameters => &
                           InversionPerturbationUpdateParameters
    procedure, public :: CalculateUpdate => InversionPerturbationCalculateUpdate
    procedure, public :: CheckConvergence => &
                           InversionPerturbationCheckConvergence
    procedure, public :: EvaluateCostFunction => &
                           InvPerturbationEvaluateCostFunction
    procedure, public :: ConnectToForwardRun => &
                           InvPerturbationConnectForwardRun
    procedure, public :: CalculateSensitivity => &
                           InvPerturbationCalculateSensitivity
    procedure, public :: UpdateRegularizParameters => &
                           InvPerturbationUpdateRegularizParams
    procedure, public :: WriteIterationInfo => &
                           InversionPerturbationWriteIterationInfo
    procedure, public :: ScaleSensitivity => &
                           InversionPerturbationScaleSensitivity
    procedure, public :: Strip => InversionPerturbationStrip
  end type inversion_perturbation_type

  type, public :: constrained_block_type
    PetscInt :: num_constrained_block
    PetscInt :: max_num_block_link
    type(constrained_block_par_type), pointer :: constrained_block_list

    ! arrays from the linked list
    character(len=MAXWORDLENGTH), pointer :: material_name(:)
    PetscInt, pointer :: material_id(:)
    PetscInt, pointer :: structure_metric(:)
    PetscInt, pointer :: wf_type(:)
    PetscInt, pointer :: block_link(:,:)
    PetscReal, pointer :: wf_mean(:)
    PetscReal, pointer :: wf_sdev(:)
    PetscReal, pointer :: relative_weight(:)
    PetscReal, pointer :: aniso_weight(:,:)
    PetscReal, pointer :: reference_permeability(:)
  end type constrained_block_type

  type constrained_block_par_type
    PetscInt :: id
    character(len=MAXWORDLENGTH) :: name
    PetscInt :: structure_metric
    PetscInt :: weighing_function
    PetscInt :: num_block_link
    character(len=MAXWORDLENGTH), pointer :: block_link(:)

    PetscReal :: aniso_weight(3)
    PetscReal :: relative_weight
    PetscReal :: weighing_function_mean
    PetscReal :: weighing_function_std_dev
    PetscReal :: reference_permeability
    type(constrained_block_par_type), pointer :: next
  end type constrained_block_par_type

  public :: InversionPerturbationCreate, &
            InversionPerturbationStrip, &
            InversionPerturbationDestroy

contains

! ************************************************************************** !

function InversionPerturbationCreate(driver)
  !
  ! Allocates and initializes a new perturbation inversion object
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21
  !
  use Driver_module

  class(driver_type), pointer :: driver

  class(inversion_perturbation_type), pointer :: InversionPerturbationCreate

  allocate(InversionPerturbationCreate)
  call InversionPerturbationCreate%Init(driver)

end function InversionPerturbationCreate

! ************************************************************************** !

subroutine InversionPerturbationInit(this,driver)
  !
  ! Initializes a new inversion object
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21
  !
  use Driver_module
  use ZFlow_Aux_module, only : zflow_calc_adjoint

  class(inversion_perturbation_type) :: this
  class(driver_type), pointer :: driver

  call InversionSubsurfaceInit(this,driver)

  this%quantity_of_interest_base = PETSC_NULL_VEC
  this%base_measurement_vec = PETSC_NULL_VEC

  this%ndof = 0
  this%idof_pert = 0
  this%pert = 0.d0
  this%perturbation_tolerance = 1.d-6
  nullify(this%select_cells)

  ! Default inversion parameters
  this%miniter = 10
  this%maxiter = 50

  this%beta = 100.d0
  this%beta_red_factor = 0.5d0
  this%minperm = 1d-17
  this%maxperm = 1d-07
  this%target_chi2 = 1.d0
  this%min_phi_red = 0.2d0

  this%start_iteration = 1
  this%maximum_iteration = 20
  this%num_constraints_local = UNINITIALIZED_INTEGER
  this%num_constraints_total = UNINITIALIZED_INTEGER
  this%current_chi2 = UNINITIALIZED_DOUBLE
  this%phi_total_0 = UNINITIALIZED_DOUBLE
  this%phi_data_0 = UNINITIALIZED_DOUBLE
  this%phi_model_0 = UNINITIALIZED_DOUBLE
  this%phi_total = UNINITIALIZED_DOUBLE
  this%phi_data = UNINITIALIZED_DOUBLE
  this%phi_model = UNINITIALIZED_DOUBLE

  this%natural_vec = PETSC_NULL_VEC

  nullify(this%b)
  nullify(this%p)
  nullify(this%q)
  nullify(this%r)
  nullify(this%s)
  nullify(this%del_perm)
  nullify(this%Wm)
  nullify(this%rblock)

  this%constrained_block => ConstrainedBlockCreate()

  zflow_calc_adjoint = PETSC_FALSE

end subroutine InversionPerturbationInit

! ************************************************************************** !

function ConstrainedBlockCreate()
  !
  ! Creates Constrained Block type
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  implicit none

  type(constrained_block_type), pointer :: ConstrainedBlockCreate
  type(constrained_block_type), pointer :: constrained_block

  allocate(constrained_block)

  constrained_block%num_constrained_block = 0
  nullify(constrained_block%constrained_block_list)

  nullify(constrained_block%material_name)
  nullify(constrained_block%material_id)
  nullify(constrained_block%structure_metric)
  nullify(constrained_block%wf_type)
  nullify(constrained_block%block_link)
  nullify(constrained_block%wf_mean)
  nullify(constrained_block%wf_sdev)
  nullify(constrained_block%relative_weight)
  nullify(constrained_block%aniso_weight)
  nullify(constrained_block%reference_permeability)

  ConstrainedBlockCreate => constrained_block

end function ConstrainedBlockCreate

! ************************************************************************** !

function ConstrainedBlockParCreate()
  !
  ! Creates Constrained Block Par type
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  implicit none

  type(constrained_block_par_type), pointer :: ConstrainedBlockParCreate
  type(constrained_block_par_type), pointer :: constrained_block

  allocate(constrained_block)
  constrained_block%id = 0
  constrained_block%name = ''

  ! Deafult is set the smoothness constraint
  constrained_block%structure_metric = 2
  constrained_block%weighing_function = 1
  constrained_block%num_block_link = 0
  nullify(constrained_block%block_link)

  constrained_block%aniso_weight = 1.d0
  constrained_block%relative_weight = 1.d0
  constrained_block%weighing_function_mean = 10.d0
  constrained_block%weighing_function_std_dev = 0.001d0
  constrained_block%reference_permeability = 0.d0
  nullify(constrained_block%next)

  ConstrainedBlockParCreate => constrained_block

end function ConstrainedBlockParCreate

! ************************************************************************** !

subroutine InversionPerturbationAllocateWorkArrays(this)
  !
  ! Initialize inversion object
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Grid_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(grid_type), pointer :: grid

  PetscInt :: num_measurement
  PetscInt :: num_constraints

  grid => this%realization%patch%grid

  num_measurement = size(this%measurements)
  num_constraints = this%num_constraints_local

  allocate(this%b(num_measurement + num_constraints))
  allocate(this%p(grid%nlmax))
  allocate(this%q(num_measurement + num_constraints))
  allocate(this%r(num_measurement + num_constraints))
  allocate(this%s(grid%nlmax))
  allocate(this%del_perm(grid%nlmax))

  this%b = 0.d0
  this%p = 0.d0
  this%q = 0.d0
  this%r = 0.d0
  this%s = 0.d0
  this%del_perm = 0.d0

end subroutine InversionPerturbationAllocateWorkArrays

! ************************************************************************** !

subroutine InversionPerturbationDeallocateWorkArrays(this)
  !
  ! Initialize inversion object
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Utility_module, only : DeallocateArray

  implicit none

  class(inversion_perturbation_type) :: this

  call DeallocateArray(this%b)
  call DeallocateArray(this%p)
  call DeallocateArray(this%q)
  call DeallocateArray(this%r)
  call DeallocateArray(this%s)
  call DeallocateArray(this%del_perm)

end subroutine InversionPerturbationDeallocateWorkArrays

! ************************************************************************** !

subroutine InversionPerturbationConstrainedArraysFromList(this)
  !
  ! Gets Constrained Block parameter arrays from linked list
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Option_module
  use Material_module
  use Patch_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(patch_type), pointer :: patch
  type(option_type), pointer :: option
  type(material_property_type), pointer :: material_property
  type(constrained_block_type), pointer :: constrained_block
  type(constrained_block_par_type), pointer :: cur_constrained_block

  PetscInt :: i,iconblock
  PetscInt :: nconblock

  patch => this%realization%patch
  option => this%realization%option

  constrained_block => this%constrained_block
  nconblock = constrained_block%num_constrained_block

  if (nconblock > 0) then
    allocate(constrained_block%material_name(nconblock))
    constrained_block%material_name = ''
    allocate(constrained_block%material_id(nconblock))
    constrained_block%material_id = 0
    allocate(constrained_block%structure_metric(nconblock))
    constrained_block%structure_metric = 2
    allocate(constrained_block%wf_type(nconblock))
    constrained_block%wf_type = 1
    allocate(constrained_block%wf_mean(nconblock))
    constrained_block%wf_mean = 10.d0
    allocate(constrained_block%wf_sdev(nconblock))
    constrained_block%wf_sdev = 0.001d0
    allocate(constrained_block%relative_weight(nconblock))
    constrained_block%relative_weight = 1.d0
    allocate(constrained_block%aniso_weight(nconblock,THREE_INTEGER))
    constrained_block%aniso_weight = 1.d0
    allocate(constrained_block%reference_permeability(nconblock))
    constrained_block%reference_permeability = 0.d0
    allocate(constrained_block%block_link(nconblock,&
             constrained_block%max_num_block_link+1))
    constrained_block%block_link = 0

    cur_constrained_block => constrained_block%constrained_block_list
    iconblock = 1
    do
      if (.not. associated(cur_constrained_block)) exit
      constrained_block%material_name(iconblock) = cur_constrained_block%name
      material_property => &
          MaterialPropGetPtrFromArray(cur_constrained_block%name, &
                                      patch%material_property_array)
      if (.not.associated(material_property)) then
        option%io_buffer = 'Contrained block " &
                           &' // trim(cur_constrained_block%name) // &
                           &'" not found in material list'
        call PrintErrMsg(option)
      endif

      constrained_block%material_id(iconblock) = material_property%internal_id
      constrained_block%structure_metric(iconblock) = &
                        cur_constrained_block%structure_metric
      constrained_block%wf_type(iconblock) = &
                        cur_constrained_block%weighing_function
      constrained_block%wf_mean(iconblock) = &
                        cur_constrained_block%weighing_function_mean
      constrained_block%wf_sdev(iconblock) = &
                        cur_constrained_block%weighing_function_std_dev
      constrained_block%relative_weight(iconblock) = &
                        cur_constrained_block%relative_weight
      constrained_block%aniso_weight(iconblock,:) = &
                        cur_constrained_block%aniso_weight
      constrained_block%reference_permeability(iconblock) = &
                        cur_constrained_block%reference_permeability
      constrained_block%block_link(iconblock,ONE_INTEGER) = &
                        cur_constrained_block%num_block_link
      do i=1,cur_constrained_block%num_block_link
        material_property => &
            MaterialPropGetPtrFromArray(cur_constrained_block%block_link(i), &
                                      patch%material_property_array)
        if (.not.associated(material_property)) then
          option%io_buffer = 'Linked block "&
                             &'//trim(cur_constrained_block%block_link(i)) // &
                             &'" in contrained block "&
                             &'//trim(cur_constrained_block%name) // &
                             &'" not found in material list'
          call PrintErrMsg(option)
        endif
        constrained_block%block_link(iconblock,i+1) = &
                                      material_property%internal_id
      enddo

      cur_constrained_block => cur_constrained_block%next
      iconblock = iconblock + 1

    enddo
  endif

end subroutine InversionPerturbationConstrainedArraysFromList

! ************************************************************************** !

subroutine InversionPerturbationReadBlock(this,input,option)

  use Input_Aux_module
  use Option_module
  use String_module
  use Utility_module

  class(inversion_perturbation_type) :: this
  type(input_type), pointer :: input
  type(option_type) :: option

  character(len=MAXWORDLENGTH) :: keyword
  character(len=MAXSTRINGLENGTH) :: error_string
  PetscBool :: found

  error_string = 'Perturbation Inversion'

  input%ierr = 0
  call InputPushBlock(input,option)
  do

    call InputReadPflotranString(input,option)
    if (InputError(input)) exit
    if (InputCheckExit(input,option)) exit

    call InputReadCard(input,option,keyword)
    call InputErrorMsg(input,option,'keyword',error_string)
    call StringToUpper(keyword)

    found = PETSC_TRUE
    call InversionSubsurfReadSelectCase(this,input,keyword,found, &
                                        error_string,option)
    if (found) cycle

    select case(trim(keyword))
      case('PERTURBATION_TOLERANCE')
        call InputReadDouble(input,option,this%perturbation_tolerance)
        call InputErrorMsg(input,option,keyword,error_string)
      case('SELECT_CELLS')
        call UtilityReadArray(this%select_cells,ZERO_INTEGER,error_string, &
                              input,option)
      case('MIN_PERMEABILITY')
        call InputReadDouble(input,option,this%minperm)
        call InputErrorMsg(input,option,'MIN_PERMEABILITY', &
                           error_string)
      case('MAX_PERMEABILITY')
        call InputReadDouble(input,option,this%maxperm)
        call InputErrorMsg(input,option,'MAX_PERMEABILITY', &
                           error_string)
      case('MIN_CGLS_ITERATION')
        call InputReadInt(input,option,this%miniter)
        call InputErrorMsg(input,option,'MIN_CGLS_ITERATION',error_string)
      case('MAX_CGLS_ITERATION')
        call InputReadInt(input,option,this%maxiter)
        call InputErrorMsg(input,option,'MAX_CGLS_ITERATION',error_string)
      case('BETA')
        call InputReadDouble(input,option,this%beta)
        call InputErrorMsg(input,option,'BETA',error_string)
      case('BETA_REDUCTION_FACTOR')
        call InputReadDouble(input,option,this%beta_red_factor)
        call InputErrorMsg(input,option,'BETA_REDUCTION_FACTOR',error_string)
      case('TARGET_CHI2')
        call InputReadDouble(input,option,this%target_chi2)
        call InputErrorMsg(input,option,'TARGET_CHI2',error_string)
      case('MIN_COST_REDUCTION')
        call InputReadDouble(input,option,this%min_phi_red)
        call InputErrorMsg(input,option,'MIN_COST_REDUCTION',error_string)
      case('CONSTRAINED_BLOCKS')
        call ConstrainedBlockRead(this%constrained_block,input,option)
      case default
        call InputKeywordUnrecognized(input,keyword,error_string,option)
    end select

  enddo
  call InputPopBlock(input,option)

end subroutine InversionPerturbationReadBlock

! ************************************************************************** !

subroutine ConstrainedBlockRead(constrained_block,input,option)
  !
  ! Read constrained blocks options
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22

  use Input_Aux_module
  use Option_module
  use String_module

  implicit none

  type(constrained_block_type) :: constrained_block
  type(input_type), pointer :: input
  type(option_type) :: option

  type(constrained_block_par_type), pointer :: cur_constrained_block
  type(constrained_block_par_type), pointer :: prev_constrained_block

  character(len=MAXWORDLENGTH) :: error_string

  error_string = 'INVERSION,CONSTRAINED_BLOCKS'

  nullify(prev_constrained_block)
  call InputPushBlock(input,option)
  constrained_block%max_num_block_link = 0
  do
    call InputReadPflotranString(input,option)
    if (InputError(input)) exit
    if (InputCheckExit(input,option)) exit

    constrained_block%num_constrained_block = &
                          constrained_block%num_constrained_block + 1

    cur_constrained_block => ConstrainedBlockParCreate()
    call InputReadCard(input,option,cur_constrained_block%name)
    call InputErrorMsg(input,option,'keyword',error_string)

    call ConstrainedBlockParRead(cur_constrained_block,input,option)
    if (constrained_block%max_num_block_link < &
        cur_constrained_block%num_block_link) &
      constrained_block%max_num_block_link = &
        cur_constrained_block%num_block_link

    if (.not.associated(constrained_block%constrained_block_list)) then
      constrained_block%constrained_block_list => cur_constrained_block
      cur_constrained_block%id = 1
    endif
    if (associated(prev_constrained_block)) then
      prev_constrained_block%next => cur_constrained_block
      cur_constrained_block%id = prev_constrained_block%id + 1
    endif
    prev_constrained_block => cur_constrained_block
    nullify(cur_constrained_block)
  enddo
  call InputPopBlock(input,option)

end subroutine ConstrainedBlockRead

! ************************************************************************** !

subroutine ConstrainedBlockParRead(constrained_block,input,option)
  !
  ! Read constrained blocks parameters options
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22

  use Input_Aux_module
  use Option_module
  use String_module

  implicit none

  type(constrained_block_par_type) :: constrained_block
  type(input_type), pointer :: input
  type(option_type) :: option

  PetscInt :: i,num_block_link
  PetscReal :: norm_factor
  character(len=MAXWORDLENGTH) :: word
  character(len=MAXWORDLENGTH) :: error_string

  error_string = 'INVERSION,CONSTRAINED_BLOCKS'

  word = ''

  call InputPushBlock(input,option)
  do
    call InputReadPflotranString(input,option)
    if (InputError(input)) exit
    if (InputCheckExit(input,option)) exit

    call InputReadCard(input,option,word)
    call InputErrorMsg(input,option,'keyword',error_string)
    call StringToUpper(word)
    select case(trim(word))
      case('STRUCTURE_METRIC')
        call InputReadInt(input,option,constrained_block%structure_metric)
        call InputErrorMsg(input,option,'STRUCTURE_METRIC',error_string)
      case('WEIGHING_FUNCTION')
        call InputReadInt(input,option,constrained_block%weighing_function)
        call InputErrorMsg(input,option,'WEIGHING_FUNCTION',error_string)
      case('WEIGHING_FUNCTION_MEAN')
        call InputReadDouble(input,option, &
                            constrained_block%weighing_function_mean)
        call InputErrorMsg(input,option,'WEIGHING_FUNCTION_MEAN',error_string)
      case('WEIGHING_FUNCTION_STD_DEVIATION')
        call InputReadDouble(input,option, &
                            constrained_block%weighing_function_std_dev)
        call InputErrorMsg(input,option,'WEIGHING_FUNCTION_STD_DEVIATION', &
                          error_string)
      case('BLOCK_LINKS')
        call InputReadInt(input,option,num_block_link)
        call InputErrorMsg(input,option,'BLOCK_LINKS',error_string)
        constrained_block%num_block_link = num_block_link
        allocate(constrained_block%block_link(num_block_link))
        do i=1,num_block_link
          call InputReadCard(input,option,constrained_block%block_link(i))
          call InputErrorMsg(input,option,'BLOCK_LINKS',error_string)
        enddo
      case('ANISOTROPIC_WEIGHTS')
        do i=1,THREE_INTEGER
          call InputReadDouble(input,option,constrained_block%aniso_weight(i))
          call InputErrorMsg(input,option,'ANISOTROPY_WEIGHTS',error_string)
        enddo
        norm_factor = norm2(constrained_block%aniso_weight)
        if (norm_factor > 0.) constrained_block%aniso_weight = &
                                constrained_block%aniso_weight / norm_factor
      case('RELATIVE_WEIGHT')
        call InputReadDouble(input,option,constrained_block%relative_weight)
        call InputErrorMsg(input,option,'RELATIVE_WEIGHT',error_string)
      case('REFERENCE_PERMEABILITY')
        call InputReadDouble(input,option, &
                            constrained_block%reference_permeability)
        call InputErrorMsg(input,option,'REFERENCE_PERMEABILITY',error_string)
      case default
        call InputKeywordUnrecognized(input,word,error_string,option)
    end select
  enddo
  call InputPopBlock(input,option)

end subroutine ConstrainedBlockParRead

! ************************************************************************** !

subroutine InversionPerturbationInitialize(this)
  !
  ! Initializes inversion
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21
  !
  use Discretization_module
  use Inversion_TS_Aux_module
  use Option_module
  use String_module
  use Variables_module, only : PERMEABILITY

  class(inversion_perturbation_type) :: this

  PetscBool :: exists
  character(len=MAXWORDLENGTH) :: word
  PetscErrorCode :: ierr

  call InversionSubsurfInitialize(this)
  call InvForwardAuxDestroyList(this%inversion_aux%inversion_forward_aux, &
                                PETSC_FALSE)
  this%inversion_aux%inversion_forward_aux%store_adjoint = PETSC_FALSE

  if (this%idof_pert == 0) then
    if (associated(this%select_cells)) then
      this%ndof = size(this%select_cells)
      if (this%ndof > this%realization%patch%grid%nmax) then
        call this%driver%PrintErrMsg('Number of SELECT_CELLS is larger than &
                                     &the problem size: '// &
                                     trim(StringWrite(this%ndof))//' '// &
                  trim(StringWrite(this%realization%patch%grid%nmax)))
      endif
    else
      this%ndof = this%realization%patch%grid%nmax
    endif
    call VecDuplicate(this%measurement_vec,this%base_measurement_vec, &
                      ierr);CHKERRQ(ierr)
  else
    if (this%idof_pert > this%realization%patch%grid%nmax) then
      call this%driver%PrintErrMsg('SELECT_CELLS ID is larger than &
                                   &the problem size: '// &
                          trim(StringWrite(this%idof_pert))//' '// &
                    trim(StringWrite(this%realization%patch%grid%nmax)))
    endif
  endif

  if (this%natural_vec == PETSC_NULL_VEC) then
    call DiscretizationCreateVector(this%realization%discretization, &
                                    ONEDOF,this%natural_vec,NATURAL, &
                                    this%realization%option)
  endif

  if (Uninitialized(this%iqoi(1))) then
    call this%driver%PrintErrMsg('Quantity of interest not specified in &
      &InversionPerturbationInitialize.')
  endif

  ! check to ensure that quantity of interest exists
  exists = PETSC_FALSE
  select case(this%iqoi(1))
    case(PERMEABILITY)
      if (this%realization%option%iflowmode /= NULL_MODE) exists = PETSC_TRUE
      word = 'PERMEABILITY'
    case default
  end select
  if (.not.exists) then
    this%realization%option%io_buffer = 'Inversion for ' // trim(word) // &
      &' cannot be performed with the specified process models.'
    call PrintErrMsg(this%realization%option)
  endif

  call InversionPerturbationConstrainedArraysFromList(this)

  ! Build Wm matrix
  call InversionPerturbationBuildWm(this)

end subroutine InversionPerturbationInitialize

! ************************************************************************** !

subroutine InversionPerturbationStep(this)
  !
  ! Execute a simulation
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21

  use Option_module
  use Factory_Forward_module
  use String_module

  class(inversion_perturbation_type) :: this

  type(option_type), pointer :: option
  PetscInt :: iteration

  ! this routine runs the modeling, checks convergence, and
  ! thereafter builds sensitivity matrix using perturbation
  call this%CalculateSensitivity()
  call this%OutputSensitivity('')
  if (.not.this%converg_flag) then
    call this%ScaleSensitivity()
    call this%CalculateUpdate()
    call this%UpdateParameters()
    call this%UpdateRegularizParameters()
  endif

  nullify(this%realization)
  call this%forward_simulation%FinalizeRun()
  call this%forward_simulation%Strip()
  deallocate(this%forward_simulation)
  nullify(this%forward_simulation)

  this%converg_flag = PETSC_FALSE
  if (this%iteration > this%maximum_iteration) this%converg_flag = PETSC_TRUE

end subroutine InversionPerturbationStep

! ************************************************************************** !

subroutine InvPerturbationCalculateSensitivity(this)
  !
  ! Calculates sensitivity matrix Jsensitivity
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/22/22
  !

  use Option_module
  use Factory_Forward_module
  use String_module

  class(inversion_perturbation_type) :: this

  type(option_type), pointer :: option
  PetscInt :: iteration,ierr

  iteration = 0
  do
    if (associated(this%select_cells) .and. iteration > 0) then
      this%idof_pert = this%select_cells(iteration)
    else
      this%idof_pert = iteration
    endif
    option => OptionCreate()
    option%group_prefix = 'Run' // trim(StringWrite(this%iteration)) // &
                          '_' // StringWrite(iteration)
    call OptionSetDriver(option,this%driver)
    call OptionSetInversionOption(option,this%inversion_option)
    call FactoryForwardInitialize(this%forward_simulation, &
                                  this%forward_simulation_filename,option)
    this%realization => this%forward_simulation%realization
    call this%Initialize()
    call this%forward_simulation%InitializeRun()
    call this%ConnectToForwardRun()
    if (option%status == PROCEED) then
      call this%forward_simulation%ExecuteRun()
    endif
    call InversionPerturbationFillRow(this,iteration)
    if (iteration == 0) then
      ! check convergence and write inversion iteration info
      call this%CheckConvergence()
      call this%WriteIterationInfo()
      !if (this%converg_flag) return
    endif
    if (iteration < this%ndof) then
      nullify(this%realization)
      call this%forward_simulation%FinalizeRun()
      call this%forward_simulation%Strip()
      deallocate(this%forward_simulation)
      nullify(this%forward_simulation)
    endif
    iteration = iteration + 1
    if (iteration > this%ndof) exit
  enddo

end subroutine InvPerturbationCalculateSensitivity

! ************************************************************************** !

subroutine InvPerturbationConnectForwardRun(this)
  !
  ! Initializes inversion
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21
  !
  use Discretization_module
  use Material_module

  class(inversion_perturbation_type) :: this

  type(discretization_type), pointer :: discretization
  Vec :: work
  Vec :: natural_vec
  PetscReal, pointer :: vec_ptr(:)
  PetscReal :: rmin, rmax
  PetscErrorCode :: ierr

  call InvSubsurfConnectToForwardRun(this)

  ! on first pass, store and set thereafter
  if (this%quantity_of_interest_base == PETSC_NULL_VEC) then
    call VecDuplicate(this%quantity_of_interest, &
                      this%quantity_of_interest_base,ierr);CHKERRQ(ierr)
  endif
  if (this%idof_pert == 0) then
    call VecCopy(this%quantity_of_interest,this%quantity_of_interest_base, &
                                     ierr);CHKERRQ(ierr)
  else
    discretization => this%realization%discretization
    work = this%realization%field%work
    call DiscretizationCreateVector(discretization, &
                                    ONEDOF,natural_vec, &
                                    NATURAL,this%realization%option)
    call VecCopy(this%quantity_of_interest_base,this%quantity_of_interest, &
                 ierr);CHKERRQ(ierr)
    call VecGetArrayF90(this%quantity_of_interest,vec_ptr, &
                        ierr);CHKERRQ(ierr)
    call VecZeroEntries(natural_vec,ierr);CHKERRQ(ierr)
    if (this%driver%comm%myrank == 0) then
      call VecSetValue(natural_vec,this%idof_pert-1, &
                       this%perturbation_tolerance,INSERT_VALUES, &
                       ierr);CHKERRQ(ierr)
    endif
    call VecAssemblyBegin(natural_vec,ierr);CHKERRQ(ierr)
    call VecAssemblyEnd(natural_vec,ierr);CHKERRQ(ierr)
    call DiscretizationNaturalToGlobal(discretization,natural_vec, &
                                       work,ONEDOF)
    call VecPointwiseMult(work,work,this%quantity_of_interest,ierr);CHKERRQ(ierr)
    call VecMax(work,PETSC_NULL_INTEGER,rmax,ierr);CHKERRQ(ierr)
    call VecMin(work,PETSC_NULL_INTEGER,rmin,ierr);CHKERRQ(ierr)
    if (rmax > 0.d0) then
      this%pert = rmax
    else
      this%pert = rmin
    endif
    call VecAXPY(this%quantity_of_interest,1.d0,work,ierr);CHKERRQ(ierr)
    call DiscretizationGlobalToLocal(this%realization%discretization, &
                                     this%quantity_of_interest, &
                                     this%realization%field%work_loc,ONEDOF)
    call MaterialSetAuxVarVecLoc(this%realization%patch%aux%Material, &
                                 this%realization%field%work_loc, &
                                 this%iqoi(1),this%iqoi(2))
    call VecDestroy(natural_vec,ierr);CHKERRQ(ierr)
  endif

end subroutine InvPerturbationConnectForwardRun

! ************************************************************************** !

subroutine InversionPerturbationFillRow(this,iteration)
  !
  ! Initializes inversion
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21
  !
  use Debug_module
  use Variables_module, only : LIQUID_PRESSURE
  use Realization_Base_class
  use String_module

  class(inversion_perturbation_type) :: this
  PetscInt :: iteration

  character(len=MAXSTRINGLENGTH) :: string
  PetscReal, pointer :: vec_ptr(:)
  PetscInt :: i
  PetscErrorCode :: ierr


  call VecGetArrayF90(this%measurement_vec,vec_ptr,ierr)
  do i = 1, size(this%measurements)
    vec_ptr(i) = this%measurements(i)%simulated_value
  enddo
  call VecRestoreArrayF90(this%measurement_vec,vec_ptr,ierr)

  if (this%idof_pert == 0) then
    call VecCopy(this%measurement_vec,this%base_measurement_vec, &
                 ierr);CHKERRQ(ierr)
    call MatZeroEntries(this%inversion_aux%JsensitivityT,ierr);CHKERRQ(ierr)
  else
    call VecAXPY(this%measurement_vec,-1.d0,this%base_measurement_vec, &
                 ierr);CHKERRQ(ierr)
    call VecScale(this%measurement_vec,1.d0/this%pert,ierr);CHKERRQ(ierr)
  endif

  if (this%idof_pert == 0) return

  ! don't need to use the distributed vec, but why not
  call VecScatterBegin(this%scatter_measure_to_dist_measure, &
                       this%measurement_vec,this%dist_measurement_vec, &
                       INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                       ierr);CHKERRQ(ierr)
  call VecScatterEnd(this%scatter_measure_to_dist_measure, &
                     this%measurement_vec,this%dist_measurement_vec, &
                     INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                     ierr);CHKERRQ(ierr)
  call VecGetArrayF90(this%dist_measurement_vec,vec_ptr,ierr);CHKERRQ(ierr)
  do i = 1, size(vec_ptr)
    call MatSetValue(this%inversion_aux%JsensitivityT,this%idof_pert-1, &
                     this%dist_measurement_offset+i-1,vec_ptr(i), &
                     INSERT_VALUES,ierr);CHKERRQ(ierr)
  enddo
  call VecRestoreArrayF90(this%dist_measurement_vec,vec_ptr,ierr);CHKERRQ(ierr)

  if (iteration == this%ndof) then
    call MatAssemblyBegin(this%inversion_aux%JsensitivityT,MAT_FINAL_ASSEMBLY, &
                          ierr);CHKERRQ(ierr)
    call MatAssemblyEnd(this%inversion_aux%JsensitivityT,MAT_FINAL_ASSEMBLY, &
                        ierr);CHKERRQ(ierr)
    call InversionPerturbationResetToBase(this)
  endif

end subroutine InversionPerturbationFillRow

! ************************************************************************** !

subroutine InversionPerturbationResetToBase(this)
  !
  ! resets all vectors to the base model
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/22/22
  !
  use Discretization_module
  use Material_module

  class(inversion_perturbation_type) :: this

  PetscErrorCode :: ierr

  ! reset measurement vectors to the base model
  call VecCopy(this%base_measurement_vec,this%measurement_vec, &
               ierr);CHKERRQ(ierr)
  call VecScatterBegin(this%scatter_measure_to_dist_measure, &
                       this%measurement_vec,this%dist_measurement_vec, &
                       INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                       ierr);CHKERRQ(ierr)
  call VecScatterEnd(this%scatter_measure_to_dist_measure, &
                     this%measurement_vec,this%dist_measurement_vec, &
                     INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                     ierr);CHKERRQ(ierr)

  ! reset material property to the base model
  call VecCopy(this%quantity_of_interest_base,this%quantity_of_interest, &
               ierr);CHKERRQ(ierr)
  call DiscretizationGlobalToLocal(this%realization%discretization, &
                                   this%quantity_of_interest, &
                                   this%realization%field%work_loc,ONEDOF)
  call MaterialSetAuxVarVecLoc(this%realization%patch%aux%Material, &
                               this%realization%field%work_loc, &
                               this%iqoi(1),this%iqoi(2))

end subroutine InversionPerturbationResetToBase

! ************************************************************************** !

subroutine InversionPerturbationCheckConvergence(this)
  !
  ! Check Inversion convergence
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/22/22

  implicit none

  class(inversion_perturbation_type) :: this

  this%converg_flag = PETSC_FALSE
  call this%EvaluateCostFunction()
  if ((this%current_chi2 <= this%target_chi2) .or. &
      (this%iteration > this%maximum_iteration)) this%converg_flag = PETSC_TRUE

end subroutine InversionPerturbationCheckConvergence

! ************************************************************************** !

subroutine InvPerturbationEvaluateCostFunction(this)
  !
  ! Evaluates cost functions for inversion
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/22/22

  use Realization_Base_class
  use Option_module
  use Patch_module
  use Material_Aux_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(material_auxvar_type), pointer :: material_auxvars(:)
  type(option_type), pointer :: option
  type(patch_type), pointer :: patch
  type(constrained_block_type), pointer :: constrained_block

  PetscInt :: idata,num_measurement
  PetscInt :: iconst,num_constraints
  PetscInt :: irb,ghosted_id,ghosted_id_nb
  PetscInt, pointer :: rblock(:,:)
  PetscReal :: wd,tempreal
  PetscReal, pointer :: vec_ptr(:)
  PetscReal :: perm_ce,perm_nb              ! cell's and neighbor's
  PetscReal :: wm,x
  PetscReal, allocatable :: model_vector(:)
  PetscErrorCode :: ierr

  option => this%realization%option
  patch => this%realization%patch
  material_auxvars => patch%aux%Material%auxvars

  constrained_block => this%constrained_block
  rblock => this%rblock

  num_measurement = size(this%measurements)

  ! Data part
  this%phi_data = 0.d0
  do idata=1,num_measurement

    wd = 0.05 * this%measurements(idata)%value
    wd = 1/wd

    tempreal = wd * (this%measurements(idata)%value - &
                     this%measurements(idata)%simulated_value)
    this%phi_data = this%phi_data + tempreal * tempreal

  enddo

  this%current_chi2 = this%phi_data / num_measurement

  ! model cost function
  this%phi_model = 0.d0
  num_constraints = this%num_constraints_local
  allocate(model_vector(num_constraints))
  model_vector = 0.d0

  do iconst=1,num_constraints
    if (this%Wm(iconst) == 0) cycle

    wm = this%Wm(iconst)

    ! get perm & block of the ith constrained eq.
    ghosted_id = rblock(iconst,1)
    ghosted_id_nb = rblock(iconst,2)
    if ((patch%imat(ghosted_id) <= 0) .or. &
        (patch%imat(ghosted_id_nb) <= 0)) cycle
    irb = rblock(iconst,3)
    perm_ce = material_auxvars(ghosted_id)%permeability(perm_xx_index)
    x = 0.d0

    select case(constrained_block%structure_metric(irb))
      case(1)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(2)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = abs(log(perm_ce) - log(perm_nb))
      case(3)
        x = log(perm_ce) - log(constrained_block%reference_permeability(irb))
      case(4)
        x = abs(log(perm_ce) - &
                log(constrained_block%reference_permeability(irb)))
      case(5)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(6)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = abs(log(perm_ce) - log(perm_nb))
      case(7)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = (log(perm_ce)- log(constrained_block%reference_permeability(irb))) &
          -(log(perm_nb) - log(constrained_block%reference_permeability(irb)))
      case(8)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = abs( &
            (log(perm_ce)- log(constrained_block%reference_permeability(irb))) &
          -(log(perm_nb) - log(constrained_block%reference_permeability(irb))) )
      case(9)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(10)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = abs(log(perm_ce) - log(perm_nb))
      case default

    end select

    model_vector(iconst) = wm * x

  enddo

  this%phi_model = this%beta * dot_product(model_vector,model_vector)
  call MPI_Allreduce(MPI_IN_PLACE,this%phi_model,ONE_INTEGER_MPI, &
                     MPI_DOUBLE_PRECISION,MPI_SUM,option%mycomm,ierr)
  deallocate(model_vector)

  this%phi_total = this%phi_data + this%phi_model

  if (this%iteration == this%start_iteration) then
    this%phi_data_0 = this%phi_data
    this%phi_model_0 = this%phi_model
    this%phi_total_0 = this%phi_total
  endif

end subroutine InvPerturbationEvaluateCostFunction

! ************************************************************************** !

subroutine InvPerturbationUpdateRegularizParams(this)
  !
  ! Check Beta if it needs cooling/reduction
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22

  implicit none

  class(inversion_perturbation_type) :: this

  if (this%iteration == this%start_iteration) return

  if ( (this%phi_total_0 - this%phi_total)/this%phi_total_0 <= &
                                                      this%min_phi_red ) then
    this%beta = this%beta * this%beta_red_factor
    this%phi_model = this%beta_red_factor * this%phi_model
  endif

  ! update the cost functions
  this%phi_data_0 = this%phi_data
  this%phi_model_0 = this%phi_model
  this%phi_total_0 = this%phi_total

end subroutine InvPerturbationUpdateRegularizParams

! ************************************************************************** !

subroutine InversionPerturbationUpdateParameters(this)
  !
  ! Updates input parameters
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Material_module
  use Discretization_module
  use Field_module

  class(inversion_perturbation_type) :: this

  type(field_type), pointer :: field
  type(discretization_type), pointer :: discretization

  PetscInt :: local_id,ghosted_id
  PetscReal, pointer :: vec_ptr(:)
  PetscErrorCode :: ierr

  field => this%realization%field
  discretization => this%realization%discretization

  call DiscretizationGlobalToLocal(discretization,this%quantity_of_interest, &
                                   field%work_loc,ONEDOF)
  call MaterialSetAuxVarVecLoc(this%realization%patch%aux%Material, &
                               field%work_loc,this%iqoi(1),this%iqoi(2))

end subroutine InversionPerturbationUpdateParameters

! ************************************************************************** !

subroutine InversionPerturbationCalculateUpdate(this)
  !
  ! Calculates updated model parameters
  ! using m_new = m_old + del_m
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !
  use Discretization_module
  use Patch_module
  use Grid_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(patch_type), pointer :: patch
  type(grid_type), pointer :: grid

  PetscInt :: local_id,ghosted_id
  PetscReal, pointer :: vec_ptr(:)
  PetscReal, pointer :: vec2_ptr(:)
  PetscErrorCode :: ierr

  patch => this%realization%patch
  grid => patch%grid

  if (this%quantity_of_interest /= PETSC_NULL_VEC) then

    call InversionPerturbationAllocateWorkArrays(this)

    ! get inversion%del_perm
    call InversionPerturbationCGLSSolve(this)

    call VecGetArrayF90(this%natural_vec,vec_ptr,ierr);CHKERRQ(ierr)
    vec_ptr(:) = this%del_perm(:)
    call VecRestoreArrayF90(this%natural_vec,vec_ptr,ierr);CHKERRQ(ierr)
    call DiscretizationNaturalToGlobal(this%realization%discretization, &
                                       this%natural_vec, &
                                       this%realization%field%work,ONEDOF)

    ! Get updated permeability as m_new = m_old + del_m (where m = log(perm))
    call VecGetArrayF90(this%quantity_of_interest,vec_ptr,ierr);CHKERRQ(ierr)
    call VecGetArrayF90(this%realization%field%work,vec2_ptr,ierr);CHKERRQ(ierr)
    do local_id=1,grid%nlmax
      ghosted_id = grid%nL2G(local_id)
      if (patch%imat(ghosted_id) <= 0) cycle
      vec_ptr(local_id) = exp(log(vec_ptr(local_id)) + vec2_ptr(local_id))
      if (vec_ptr(local_id) > this%maxperm) vec_ptr(local_id) = this%maxperm
      if (vec_ptr(local_id) < this%minperm) vec_ptr(local_id) = this%minperm
    enddo
    call VecRestoreArrayF90(this%quantity_of_interest,vec_ptr, &
                            ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(this%realization%field%work,vec2_ptr, &
                            ierr);CHKERRQ(ierr)
    call InversionPerturbationDeallocateWorkArrays(this)

  endif

end subroutine InversionPerturbationCalculateUpdate

! ************************************************************************** !

subroutine InversionPerturbationCGLSSolve(this)
  !
  ! Implements CGLS solver for least sqaure equivalent
  !            of the Perturbation normal equations
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Option_module
  use Timer_class
  use String_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(option_type), pointer :: option
  class(timer_type), pointer :: timer

  PetscInt :: i,nm,ncons
  PetscReal :: alpha,gbeta,gamma,gamma1,delta1,delta2,delta
  PetscReal :: norms0,norms,normx,xmax
  PetscReal :: resNE,resNE_old
  PetscBool :: exit_info,indefinite
  PetscBool :: lprint, l2print
  PetscErrorCode :: ierr

  PetscReal, parameter :: delta_initer = 1e-23
  PetscReal, parameter :: initer_conv  = 1e-24

  option => this%realization%option

  this%del_perm = 0.0d0

  timer => TimerCreate()
  call timer%Start()

  if (OptionPrintToScreen(option)) then
    write(*,'(" --> Solving Perturbation normal equation using CGLS solver:")')
  endif

  nm = size(this%measurements)
  ncons = this%num_constraints_local

  ! Get RHS vector this%b
  call InversionPerturbationCGLSRhs(this)

  this%r = this%b

  ! get this%s = J^tr
  call InversionPerturbationComputeMatVecProductJtr(this)
  this%p = this%s

  gamma = dot_product(this%s,this%s)
  call MPI_Allreduce(MPI_IN_PLACE,gamma,ONE_INTEGER_MPI, &
                     MPI_DOUBLE_PRECISION,MPI_SUM,option%mycomm,ierr)

  norms0 = sqrt(gamma)
  xmax = 0.d0
  normx = 0.d0
  resNE = 0.d0
  exit_info = PETSC_FALSE
  indefinite = PETSC_FALSE

  do i=1,this%maxiter

    if (exit_info) exit

    ! get this%q = Jp
    call InversionPerturbationComputeMatVecProductJp(this)

    delta1 = dot_product(this%q(1:nm),this%q(1:nm))
    delta2 = dot_product(this%q(nm+1:nm+ncons),this%q(nm+1:nm+ncons))
    call MPI_Allreduce(MPI_IN_PLACE,delta2,ONE_INTEGER_MPI, &
                       MPI_DOUBLE_PRECISION,MPI_SUM,option%mycomm,ierr)
    delta = delta1 + delta2

    if (delta < 0) indefinite = PETSC_TRUE
    if (delta == 0) delta = epsilon(delta)

    alpha = gamma / delta

    this%del_perm = this%del_perm + alpha * this%p
    this%r = this%r - alpha * this%q

    ! get this%s = J^tr
    call InversionPerturbationComputeMatVecProductJtr(this)

    gamma1 = gamma
    gamma = dot_product(this%s,this%s)
    call MPI_Allreduce(MPI_IN_PLACE,gamma,ONE_INTEGER_MPI, &
                       MPI_DOUBLE_PRECISION,MPI_SUM,option%mycomm,ierr)

    norms = sqrt(gamma)
    gbeta = gamma / gamma1
    this%p = this%s + gbeta * this%p

    normx = dot_product(this%del_perm,this%del_perm)
    call MPI_Allreduce(MPI_IN_PLACE,normx,ONE_INTEGER_MPI, &
                       MPI_DOUBLE_PRECISION,MPI_SUM,option%mycomm,ierr)
    normx = sqrt(normx)
    if (xmax < normx) xmax = normx
    if ( (norms <= norms0 * initer_conv) .or. (normx * initer_conv >= 1)) &
                               exit_info = PETSC_TRUE

    resNE_old = resNE
    resNE = norms / norms0

    if ( abs((resNE_old - resNe) /resNE_old) < delta_initer .and. &
        i > this%miniter) exit_info = PETSC_TRUE

  enddo

  call timer%Stop()
  option%io_buffer = '    ' // &
    trim(StringWrite('(f20.1)',timer%GetCumulativeTime())) &
    // ' seconds and ' // trim(StringWrite(i)) // &
    ' iterations to solve Perturbation normal equation.'
  call PrintMsg(option)
  call TimerDestroy(timer)

end subroutine InversionPerturbationCGLSSolve

! ************************************************************************** !

subroutine InversionPerturbationCGLSRhs(this)
  !
  ! Builds RHS for least-square equation for CGLS solver
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Realization_Base_class
  use Patch_module
  use Material_Aux_module
  use Option_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(material_auxvar_type), pointer :: material_auxvars(:)
  type(option_type), pointer :: option
  type(patch_type), pointer :: patch
  type(constrained_block_type), pointer :: constrained_block

  PetscInt :: idata,iconst,irb,num_measurement
  PetscInt, pointer :: rblock(:,:)
  PetscReal :: perm_ce,perm_nb,x     ! cell's and neighbor's
  PetscReal :: wm,beta
  PetscReal :: wd
  PetscReal, pointer :: vec_ptr(:)
  PetscErrorCode :: ierr

  option => this%realization%option
  patch => this%realization%patch
  material_auxvars => patch%aux%Material%auxvars

  constrained_block => this%constrained_block
  rblock => this%rblock

  this%b = 0.0d0

  num_measurement = size(this%measurements)

  ! Data part
  do idata=1,num_measurement

    wd = 0.05 * this%measurements(idata)%value
    wd = 1/wd

    this%b(idata) = wd * (this%measurements(idata)%value - &
                          this%measurements(idata)%simulated_value)
  enddo

  ! Model part
  beta = this%beta

  do iconst=1,this%num_constraints_local
    if (this%Wm(iconst) == 0) cycle

    wm = this%Wm(iconst)

    perm_ce = material_auxvars(rblock(iconst,1))%permeability(perm_xx_index)
    irb = rblock(iconst,3)

    select case(constrained_block%structure_metric(irb))
      case(1)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(2)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(3)
        x = log(perm_ce) - log(constrained_block%reference_permeability(irb))
      case(4)
        x = log(perm_ce) - log(constrained_block%reference_permeability(irb))
      case(5)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
        ! TODO: compute rx,ry, and rz
      case(6)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
        ! TODO: compute rx,ry, and rz
      case(7)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = (log(perm_ce)- log(constrained_block%reference_permeability(irb))) &
          -(log(perm_nb) - log(constrained_block%reference_permeability(irb)))
      case(8)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = (log(perm_ce)- log(constrained_block%reference_permeability(irb))) &
          -(log(perm_nb) - log(constrained_block%reference_permeability(irb)))
      case(9)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(10)
        perm_nb = material_auxvars(rblock(iconst,2))%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case default
        option%io_buffer = 'Supported STRUCTURE_METRIC in INVERSION, &
                            &CONSTRAINED_BLOCKS is between 1 to 10'
        call PrintErrMsg(option)
    end select

    this%b(num_measurement + iconst) = - sqrt(beta) * wm * x

  enddo

end subroutine InversionPerturbationCGLSRhs

! ************************************************************************** !

subroutine InversionPerturbationBuildWm(this)
  !
  ! Builds model regularization matrix: Wm
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Patch_module
  use Grid_module
  use Material_Aux_module
  use Option_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(material_auxvar_type), pointer :: material_auxvars(:)
  type(option_type), pointer :: option
  type(patch_type), pointer :: patch
  type(grid_type), pointer :: grid
  type(constrained_block_type), pointer :: constrained_block

  PetscInt :: i

  option => this%realization%option
  patch => this%realization%patch
  grid => patch%grid
  material_auxvars => patch%aux%Material%auxvars

  constrained_block => this%constrained_block

  if ((.not.associated(this%Wm)).or.(.not.associated(this%rblock))) &
                                 call InversionPerturbationAllocateWm(this)

  do i=1,this%num_constraints_local
    call ComputeWm(i,this%Wm(i))
  enddo

contains

  subroutine ComputeWm(iconst,wm)
    ! computes an element of Wm matrix
    !
    ! Author: Piyoosh Jaysaval
    ! Date: 03/23/22

    implicit none

    PetscInt :: iconst
    PetscReal :: wm

    PetscInt :: irb,ghosted_id,ghosted_id_nb
    PetscReal :: x,awx,awy,awz
    PetscReal :: perm_ce,perm_nb     ! cell's and neighbor's
    PetscReal :: mn,sd
    PetscReal :: rx,ry,rz,r
    PetscInt, pointer :: rblock(:,:)

    rblock => this%rblock

    ! get perm & block of the ith constrained eq.
    ghosted_id = rblock(iconst,1)
    ghosted_id_nb = rblock(iconst,2)
    if (patch%imat(ghosted_id) <= 0 .or.   &
        patch%imat(ghosted_id_nb) <=0 ) return
    irb = rblock(iconst,3)
    perm_ce = material_auxvars(ghosted_id)%permeability(perm_xx_index)
    x = 0.d0

    select case(constrained_block%structure_metric(irb))
      case(1)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(2)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = abs(log(perm_ce) - log(perm_nb))
      case(3)
        x = log(perm_ce) - log(constrained_block%reference_permeability(irb))
      case(4)
        x = abs(log(perm_ce) - &
                log(constrained_block%reference_permeability(irb)))
      case(5)
        !perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        !x = log(perm_ce) - log(perm_nb)

        ! compute unit vectors: rx,ry, and rz
        rx = grid%x(ghosted_id) - grid%x(ghosted_id_nb)
        ry = grid%y(ghosted_id) - grid%y(ghosted_id_nb)
        rz = grid%z(ghosted_id) - grid%z(ghosted_id_nb)
        r = sqrt(rx*rx + ry*ry + rz*rz)
        rx = rx / r
        ry = ry / r
        rz = rz / r
      case(6)
        !perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        !x = abs(log(perm_ce) - log(perm_nb))

        ! compute unit vectors: rx,ry, and rz
        rx = abs(grid%x(ghosted_id) - grid%x(ghosted_id_nb))
        ry = abs(grid%y(ghosted_id) - grid%y(ghosted_id_nb))
        rz = abs(grid%z(ghosted_id) - grid%z(ghosted_id_nb))
        r = sqrt(rx*rx + ry*ry + rz*rz)
        rx = rx / r
        ry = ry / r
        rz = rz / r
      case(7)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = (log(perm_ce)- log(constrained_block%reference_permeability(irb))) &
          -(log(perm_nb) - log(constrained_block%reference_permeability(irb)))
      case(8)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = abs( &
            (log(perm_ce)- log(constrained_block%reference_permeability(irb))) &
          -(log(perm_nb) - log(constrained_block%reference_permeability(irb))) )
      case(9)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = log(perm_ce) - log(perm_nb)
      case(10)
        perm_nb = material_auxvars(ghosted_id_nb)%permeability(perm_xx_index)
        x = abs(log(perm_ce) - log(perm_nb))
      case default
        option%io_buffer = 'Supported STRUCTURE_METRIC in INVERSION, &
                            &CONSTRAINED_BLOCKS is between 1 to 10'
        call PrintErrMsg(option)
    end select

    mn = constrained_block%wf_mean(irb)
    sd = constrained_block%wf_sdev(irb)
    ! Get weight w
    select case(constrained_block%wf_type(irb))
    case(1)
      wm = 0.5 * (1 - erf( (x-mn)/sqrt(2*sd*sd) ))
    case(2)
      wm = 0.5 * (1 + erf( (x-mn)/sqrt(2*sd*sd) ))
    case(3)
      wm = 1 - exp(-((x-mn)*(x-mn)) / (2*sd*sd))
    case(4)
      wm = exp(-((x-mn)*(x-mn)) / (2*sd*sd))
    case(5)
      if ((x-mn) < 0) then
         wm = 1 / (sd*sd)
      else
         wm = sd*sd / (((x-mn)*(x-mn) + sd*sd)*((x-mn)*(x-mn) + sd*sd))
      end if
    case(6)
      if ((x-mn) > 0) then
         wm = 1 / (sd*sd)
      else
        wm = sd*sd / (((x-mn)*(x-mn) + sd*sd)*((x-mn)*(x-mn) + sd*sd))
      end if
    case default
      option%io_buffer = 'Supported WEIGHING_FUNCTION in INVERSION, &
                          &CONSTRAINED_BLOCKS is between 1 to 6'
      call PrintErrMsg(option)
    end select

    if (constrained_block%structure_metric(irb) == 5 .or. &
        constrained_block%structure_metric(irb) == 6) then
      awx = constrained_block%aniso_weight(irb,1)
      awy = constrained_block%aniso_weight(irb,2)
      awz = constrained_block%aniso_weight(irb,3)
      wm = (1 - abs( awx*rx + awy*ry + awz*rz))**2
    end if

    wm = constrained_block%relative_weight(irb) * wm

  end subroutine ComputeWm

end subroutine InversionPerturbationBuildWm

! ************************************************************************** !

subroutine InversionPerturbationAllocateWm(this)
  !
  ! Allocate and get info on Wm and rblock
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Patch_module
  use Grid_module
  use Option_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(option_type), pointer :: option
  type(patch_type), pointer :: patch
  type(grid_type), pointer :: grid
  type(constrained_block_type), pointer :: constrained_block

  PetscInt :: local_id,ghosted_id,ghosted_id_nbr
  PetscInt :: iconblock,inbr,ilink
  PetscInt :: num_constraints
  PetscInt :: num_neighbor
  PetscErrorCode :: ierr

  option => this%realization%option
  patch => this%realization%patch
  grid => patch%grid

  constrained_block => this%constrained_block

  num_constraints = 0
  do local_id=1,grid%nlmax
    ghosted_id = grid%nL2G(local_id)
    if (patch%imat(ghosted_id) <= 0) cycle
    do iconblock=1,constrained_block%num_constrained_block
      if (constrained_block%structure_metric(iconblock) > 0) then
        if (constrained_block%material_id(iconblock) == &
            patch%imat(ghosted_id)) then
          if (constrained_block%structure_metric(iconblock) == 3 .or. &
              constrained_block%structure_metric(iconblock) == 4) then
            num_constraints = num_constraints + 1
          else
            num_neighbor = grid%cell_neighbors_local_ghosted(0,local_id)
            do inbr=1,num_neighbor
              ghosted_id_nbr = abs( &
                            grid%cell_neighbors_local_ghosted(inbr,local_id))
              if (patch%imat(ghosted_id_nbr) <= 0) cycle
              if (patch%imat(ghosted_id_nbr) /= patch%imat(ghosted_id)) then
                do ilink=1,constrained_block%block_link(iconblock,1)
                  if (constrained_block%block_link(iconblock,ilink+1) == &
                      patch%imat(ghosted_id_nbr)) then
                    num_constraints = num_constraints + 1
                  endif
                enddo
              else
                if (constrained_block%structure_metric(iconblock) < 9 .or. &
                    constrained_block%structure_metric(iconblock) > 10) then
                  num_constraints = num_constraints + 1
                endif
              endif
            enddo
          endif
        endif
      endif
    enddo
  enddo

  this%num_constraints_local = num_constraints
  call MPI_Allreduce(num_constraints,this%num_constraints_total, &
                     ONE_INTEGER_MPI,MPIU_INTEGER,MPI_SUM,option%mycomm,ierr)
  allocate(this%Wm(num_constraints))
  allocate(this%rblock(num_constraints,THREE_INTEGER))
  this%Wm = 0.d0
  this%rblock = 0

  ! repeat once num_constraints is known
  num_constraints = 0
  do local_id=1,grid%nlmax
    ghosted_id = grid%nL2G(local_id)
    if (patch%imat(ghosted_id) <= 0) cycle
    do iconblock=1,constrained_block%num_constrained_block
      if (constrained_block%structure_metric(iconblock) > 0) then
        if (constrained_block%material_id(iconblock) == &
            patch%imat(ghosted_id)) then
          if (constrained_block%structure_metric(iconblock) == 3 .or. &
              constrained_block%structure_metric(iconblock) == 4) then
            num_constraints = num_constraints + 1
            this%rblock(num_constraints,1) = ghosted_id
            this%rblock(num_constraints,3) = iconblock
          else
            num_neighbor = grid%cell_neighbors_local_ghosted(0,local_id)
            do inbr=1,num_neighbor
              ghosted_id_nbr = abs( &
                            grid%cell_neighbors_local_ghosted(inbr,local_id))
              if (patch%imat(ghosted_id_nbr) <= 0) cycle
              if (patch%imat(ghosted_id_nbr) /= patch%imat(ghosted_id)) then
                do ilink=1,constrained_block%block_link(iconblock,1)
                  if (constrained_block%block_link(iconblock,ilink+1) == &
                      patch%imat(ghosted_id_nbr)) then
                    num_constraints = num_constraints + 1
                    this%rblock(num_constraints,1) = ghosted_id
                    this%rblock(num_constraints,2) = ghosted_id_nbr
                    this%rblock(num_constraints,3) = iconblock
                  endif
                enddo
              else
                if (constrained_block%structure_metric(iconblock) < 9 .or. &
                    constrained_block%structure_metric(iconblock) > 10) then
                  num_constraints = num_constraints + 1
                  this%rblock(num_constraints,1) = ghosted_id
                  this%rblock(num_constraints,2) = ghosted_id_nbr
                  this%rblock(num_constraints,3) = iconblock
                endif
              endif
            enddo
          endif
        endif
      endif
    enddo
  enddo

end subroutine InversionPerturbationAllocateWm

! ************************************************************************** !

subroutine InversionPerturbationComputeMatVecProductJp(this)
  !
  ! Computes product of Jacobian J with a vector p = Jp
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Patch_module
  use Grid_module
  use Field_module
  use Discretization_module
  use Option_module
  use Inversion_Aux_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(patch_type), pointer :: patch
  type(grid_type), pointer :: grid
  type(option_type), pointer :: option
  type(field_type), pointer :: field
  type(discretization_type), pointer :: discretization
  type(constrained_block_type), pointer :: constrained_block
  type(inversion_aux_type), pointer :: inversion_aux

  PetscInt :: iconst,irb,num_measurement
  PetscInt :: ghosted_id,ghosted_id_nb
  PetscInt, pointer :: rblock(:,:)
  PetscReal :: beta,wm
  PetscReal, pointer :: pvec_ptr(:)
  PetscReal, pointer :: q1vec_ptr(:)
  PetscErrorCode :: ierr

  Vec :: p1
  Vec :: q1
  Vec :: q1_dist

  option => this%realization%option
  field => this%realization%field
  discretization => this%realization%discretization
  patch => this%realization%patch
  grid => patch%grid
  inversion_aux => this%inversion_aux

  constrained_block => this%constrained_block
  rblock => this%rblock

  this%q = 0.d0

  num_measurement = size(this%measurements)

  ! Data part
  call VecDuplicate(this%natural_vec,p1,ierr);CHKERRQ(ierr)
  call VecDuplicate(this%dist_measurement_vec,q1_dist,ierr);CHKERRQ(ierr)
  call VecDuplicate(this%measurement_vec,q1,ierr);CHKERRQ(ierr)

  call VecGetArrayF90(p1,pvec_ptr,ierr);CHKERRQ(ierr)
  pvec_ptr = this%p
  call VecRestoreArrayF90(p1,pvec_ptr,ierr);CHKERRQ(ierr)

  ! q = Jp -> data part
  call MatMultTranspose(inversion_aux%JsensitivityT,p1,q1_dist, &
                        ierr);CHKERRQ(ierr)

  call VecScatterBegin(this%scatter_measure_to_dist_measure, &
                       q1_dist,q1, &
                       INSERT_VALUES,SCATTER_REVERSE, &
                       ierr);CHKERRQ(ierr)
  call VecScatterEnd(this%scatter_measure_to_dist_measure, &
                     q1_dist,q1, &
                     INSERT_VALUES,SCATTER_REVERSE, &
                     ierr);CHKERRQ(ierr)
  call VecGetArrayF90(q1,q1vec_ptr,ierr);CHKERRQ(ierr)
  this%q(1:num_measurement) = q1vec_ptr
  call VecRestoreArrayF90(q1,q1vec_ptr,ierr);CHKERRQ(ierr)

  ! Model part -> q2
  ! Get local this%p to ghosted in pvec_ptr
  call DiscretizationNaturalToGlobal(discretization,p1, &
                                     field%work,ONEDOF)
  call DiscretizationGlobalToLocal(discretization,field%work, &
                                   field%work_loc,ONEDOF)
  call VecGetArrayF90(field%work_loc,pvec_ptr,ierr);CHKERRQ(ierr)

  beta = this%beta

  do iconst=1,this%num_constraints_local
    if (this%Wm(iconst) == 0) cycle

    wm = this%Wm(iconst)
    irb = rblock(iconst,3)
    ghosted_id = rblock(iconst,1)
    if (patch%imat(ghosted_id) <= 0) cycle

    if (constrained_block%structure_metric(irb) == 3 .or. &
        constrained_block%structure_metric(irb) == 4) then
      this%q(num_measurement + iconst) = &
        sqrt(beta) * wm * pvec_ptr(ghosted_id)
    else
      ghosted_id_nb = rblock(iconst,2)
      if (patch%imat(ghosted_id_nb) <= 0) cycle
      this%q(num_measurement + iconst) = &
          sqrt(beta) * wm * (pvec_ptr(ghosted_id) - pvec_ptr(ghosted_id_nb))
    endif
  enddo

  call VecRestoreArrayF90(field%work_loc,pvec_ptr,ierr);CHKERRQ(ierr)

  call VecDestroy(p1,ierr);CHKERRQ(ierr)
  call VecDestroy(q1,ierr);CHKERRQ(ierr)
  call VecDestroy(q1_dist,ierr);CHKERRQ(ierr)

end subroutine InversionPerturbationComputeMatVecProductJp

!************************************************************************** !

subroutine InversionPerturbationComputeMatVecProductJtr(this)
  !
  ! Computes product of Jacobian J transpose with a vector r = J^t x r
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !

  use Patch_module
  use Grid_module
  use Field_module
  use Discretization_module
  use Inversion_Aux_module

  implicit none

  class(inversion_perturbation_type) :: this

  type(patch_type), pointer :: patch
  type(grid_type), pointer :: grid
  type(field_type), pointer :: field
  type(discretization_type), pointer :: discretization
  type(constrained_block_type), pointer :: constrained_block
  type(inversion_aux_type), pointer :: inversion_aux

  PetscInt :: iconst,irb,num_measurement
  PetscInt :: ghosted_id,ghosted_id_nb
  PetscInt, pointer :: rblock(:,:)
  PetscReal :: beta,wm
  PetscReal, pointer :: r1vec_ptr(:)
  PetscReal, pointer :: s1vec_ptr(:)
  PetscReal, pointer :: s2vec_ptr(:)
  PetscErrorCode :: ierr

  Vec :: r1
  Vec :: s1

  field => this%realization%field
  discretization => this%realization%discretization
  patch => this%realization%patch
  grid => patch%grid
  inversion_aux => this%inversion_aux

  constrained_block => this%constrained_block
  rblock => this%rblock

  this%s = 0.0d0

  num_measurement = size(this%measurements)

  ! Model part -> s2
  call VecGetArrayF90(field%work_loc,s2vec_ptr,ierr);CHKERRQ(ierr)
  s2vec_ptr = 0.d0

  beta = this%beta

  do iconst=1,this%num_constraints_local
    if (this%Wm(iconst) == 0) cycle

    wm = this%Wm(iconst)
    irb = rblock(iconst,3)
    ghosted_id = rblock(iconst,1)
    if (patch%imat(ghosted_id) <= 0) cycle

    if (constrained_block%structure_metric(irb) == 3 .or. &
        constrained_block%structure_metric(irb) == 4) then
      s2vec_ptr(ghosted_id) = s2vec_ptr(ghosted_id) + &
        sqrt(beta) * wm * this%r(num_measurement + iconst)
    else
      ghosted_id_nb = rblock(iconst,2)
      if (patch%imat(ghosted_id_nb) <= 0) cycle
      s2vec_ptr(ghosted_id) = s2vec_ptr(ghosted_id) + &
              sqrt(beta) * wm * this%r(num_measurement + iconst)
      s2vec_ptr(ghosted_id_nb) = s2vec_ptr(ghosted_id_nb) - &
              sqrt(beta) * wm * this%r(num_measurement + iconst)
    endif
  enddo

  call VecRestoreArrayF90(field%work_loc,s2vec_ptr,ierr);CHKERRQ(ierr)

  ! s2 in field%work
  call VecZeroEntries(field%work,ierr);CHKERRQ(ierr)
  call DiscretizationLocalToGlobalAdd(discretization,field%work_loc, &
                                      field%work,ONEDOF)
  call DiscretizationGlobalToNatural(discretization,field%work, &
                                     this%natural_vec,ONEDOF)

  ! Data part
  call VecDuplicate(this%measurement_vec,r1,ierr);CHKERRQ(ierr)
  call VecDuplicate(this%natural_vec,s1,ierr);CHKERRQ(ierr)

  call VecGetArrayF90(r1,r1vec_ptr,ierr);CHKERRQ(ierr)
  r1vec_ptr = this%r(1:num_measurement)
  call VecRestoreArrayF90(r1,r1vec_ptr,ierr);CHKERRQ(ierr)
  call VecScatterBegin(this%scatter_measure_to_dist_measure, &
                       r1,this%dist_measurement_vec, &
                       INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                       ierr);CHKERRQ(ierr)
  call VecScatterEnd(this%scatter_measure_to_dist_measure, &
                     r1,this%dist_measurement_vec, &
                     INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                     ierr);CHKERRQ(ierr)

  call VecGetArrayF90(this%dist_measurement_vec,r1vec_ptr,ierr);CHKERRQ(ierr)
  call VecRestoreArrayF90(this%dist_measurement_vec,r1vec_ptr,ierr);CHKERRQ(ierr)

  ! s = J^T*r -> data part
  call MatMult(inversion_aux%JsensitivityT,this%dist_measurement_vec, &
               s1,ierr);CHKERRQ(ierr)

  call VecGetArrayF90(s1,s1vec_ptr,ierr);CHKERRQ(ierr)
  call VecGetArrayF90(this%natural_vec,s2vec_ptr,ierr);CHKERRQ(ierr)
  this%s = s1vec_ptr + s2vec_ptr
  call VecRestoreArrayF90(s1,s1vec_ptr,ierr);CHKERRQ(ierr)
  call VecRestoreArrayF90(this%natural_vec,s2vec_ptr,ierr);CHKERRQ(ierr)

  call VecDestroy(r1,ierr);CHKERRQ(ierr)
  call VecDestroy(s1,ierr);CHKERRQ(ierr)

end subroutine InversionPerturbationComputeMatVecProductJtr

! ************************************************************************** !

subroutine InversionPerturbationWriteIterationInfo(this)
  !
  ! Writes inversion run info
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/22/22
  !

  use String_module

  implicit none

  class(inversion_perturbation_type) :: this

  PetscInt :: fid
  PetscInt, parameter :: zeronum = 0
  character(len=MAXWORDLENGTH) :: string

  if (this%driver%PrintToScreen()) then
    write(*,*)
    write(*,98)
    if (this%iteration == this%start_iteration) then
      write(*,'(/,2x,a,i6.4,/)') StringColor("CONVERGENCE STATISTICS AT &
                              &STARTING ITERATION:",C_RED), this%start_iteration
    else
      write(*,'(/,2x,a,i6.4,/)') StringColor("CONVERGENCE STATISTICS AFTER &
                                 &ITERATION:",C_RED),this%iteration
    endif
    write(*,99)
    write(*,*) StringColor("  Phi_data   ",C_GREEN), &
               StringColor("   Phi_Model  ",C_BLUE), &
               StringColor("  Phi_Model/Beta",C_MAGENTA), &
               StringColor("    Phi_Total   ",C_CYAN)
    write(*,102) this%phi_data,this%phi_model,this%phi_model/this%beta, &
                 this%phi_total
    write(*,*)
    if (this%num_constraints_total >= 0) then
      write(*,103) this%num_constraints_total
    else
      write(*,103) zeronum
    endif
    write(*,104) this%current_chi2
    write(*,105) this%target_chi2
    write(*,106) sqrt(this%current_chi2)
    write(*,107) this%beta
    write(*,108) this%beta_red_factor
    write(*,109) 100.d0*(this%phi_total_0 - this%phi_total)/this%phi_total_0
    write(*,110) 100.d0*this%min_phi_red
    write(*,99)
    write(*,*)
    write(*,98)
  endif

  if (this%driver%PrintToFile()) then
    fid = this%driver%fid_out
    write(fid,*)
    write(fid,98)
    if (this%iteration == this%start_iteration) then
      write(fid,'(/,2x,a,i6.4,/)') "CONVERGENCE STATISTICS AT STARTING &
                                   &ITERATION:", this%start_iteration
    else
      write(fid,'(/,2x,a,i6.4,/)') "CONVERGENCE STATISTICS AFTER ITERATION:", &
                                    this%iteration
    endif
    write(fid,99)
    write(fid,101) "  Phi_data   ","   Phi_Model   "," Phi_Model/Beta", &
                  &"   Phi_Total   "
    write(fid,102) this%phi_data,this%phi_model,this%phi_model/this%beta, &
                   this%phi_total
    write(fid,*)
    if (this%num_constraints_total >= 0) then
      write(fid,103) this%num_constraints_total
    else
      write(fid,103) zeronum
    endif
    write(fid,104) this%current_chi2
    write(fid,105) this%target_chi2
    write(fid,106) sqrt(this%current_chi2)
    write(fid,107) this%beta
    write(fid,108) this%beta_red_factor
    write(fid,109) 100.d0*(this%phi_total_0 - this%phi_total)/this%phi_total_0
    write(fid,110) 100.d0*this%min_phi_red
    write(fid,99)
    write(fid,*)
    write(fid,98)
    flush(fid)
  endif

98 format(40('=+'))
99 format(80('~'))
101 format(4a15)
102 format(4g15.7)

103 format(4x,'Number of Constraint Eqs:      ',2x,i15.10)
104 format(4x,'Current Chi2:                  ',2x,f15.4)
105 format(4x,'Target Ch2:                    ',2x,f15.4)
106 format(4x,'RMS error:                     ',2x,f15.4)
107 format(4x,'Beta:                          ',2x,f15.4)
108 format(4x,'Beta reduction factor:         ',2x,f15.4)
109 format(4x,'Reduction in Phi_Total:        ',2x,f15.4," %")
110 format(4x,'Minimum reduction in Phi_Total ' /,8x, &
                 &'before Beta reduction:     ',2x,f15.4," %")

end subroutine InversionPerturbationWriteIterationInfo

! ************************************************************************** !

subroutine InversionPerturbationScaleSensitivity(this)
  !
  ! Scales sensitivity Jacobian for ln(K)
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/23/22
  !
  use Discretization_module
  use Realization_Base_class
  use Variables_module, only : PERMEABILITY

  class(inversion_perturbation_type) :: this

  Vec :: wd_vec
  PetscInt :: idata,num_measurement
  PetscReal :: wd
  PetscReal, pointer :: wdvec_ptr(:)
  PetscErrorCode :: ierr

  call RealizationGetVariable(this%realization, &
                              this%realization%field%work, &
                              PERMEABILITY,ZERO_INTEGER)
  call DiscretizationGlobalToNatural(this%realization%discretization, &
                                     this%realization%field%work, &
                                     this%natural_vec,ONEDOF)

  num_measurement = size(this%measurements)
  call VecDuplicate(this%measurement_vec,wd_vec,ierr);CHKERRQ(ierr)
  call VecZeroEntries(wd_vec,ierr);CHKERRQ(ierr)
  call VecGetArrayF90(wd_vec,wdvec_ptr,ierr);CHKERRQ(ierr)
  do idata = 1, num_measurement
    wd = 0.05 * this%measurements(idata)%value
    wd = 1/wd
    wdvec_ptr(idata) = wd
  enddo
  call VecRestoreArrayF90(wd_vec,wdvec_ptr,ierr);CHKERRQ(ierr)
  call VecScatterBegin(this%scatter_measure_to_dist_measure, &
                       wd_vec,this%dist_measurement_vec, &
                       INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                       ierr);CHKERRQ(ierr)
  call VecScatterEnd(this%scatter_measure_to_dist_measure, &
                     wd_vec,this%dist_measurement_vec, &
                     INSERT_VALUES,SCATTER_FORWARD_LOCAL, &
                     ierr);CHKERRQ(ierr)

  ! Column Scale with wd
  call MatDiagonalScale(this%inversion_aux%JsensitivityT, &
                        PETSC_NULL_VEC, & ! scales rows
                        this%dist_measurement_vec, &  ! scales columns
                        ierr);CHKERRQ(ierr)
  ! Row scale with perm
  call MatDiagonalScale(this%inversion_aux%JsensitivityT, &
                        this%natural_vec, & ! scales rows
                        PETSC_NULL_VEC, &  ! scales columns
                        ierr);CHKERRQ(ierr)
  call VecDestroy(wd_vec,ierr);CHKERRQ(ierr)

end subroutine InversionPerturbationScaleSensitivity

! ************************************************************************** !

subroutine InversionPerturbationFinalize(this)
  !
  ! Finalizes inversion
  !
  ! Author: Piyoosh Jaysaval
  ! Date: 03/22/22
  !

  implicit none

  class(inversion_perturbation_type) :: this

  call InversionBaseFinalize(this)

end subroutine InversionPerturbationFinalize

! ************************************************************************** !

subroutine InversionPerturbationStrip(this)
  !
  ! Deallocates members of inversion perturbation
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21
  !
  use Utility_module

  class(inversion_perturbation_type) :: this

  PetscErrorCode :: ierr

  call InversionSubsurfaceStrip(this)

  call DeallocateArray(this%select_cells)
  if (this%quantity_of_interest_base /= PETSC_NULL_VEC) then
    call VecDestroy(this%quantity_of_interest_base,ierr);CHKERRQ(ierr)
  endif
  if (this%base_measurement_vec /= PETSC_NULL_VEC) then
    call VecDestroy(this%base_measurement_vec,ierr);CHKERRQ(ierr)
  endif

end subroutine InversionPerturbationStrip

! ************************************************************************** !

subroutine InversionPerturbationDestroy(inversion)
  !
  ! Deallocates a inversion
  !
  ! Author: Glenn Hammond
  ! Date: 09/24/21
  !
  class(inversion_perturbation_type), pointer :: inversion

  if (.not.associated(inversion)) return

  call inversion%Strip()
  deallocate(inversion)
  nullify(inversion)

end subroutine InversionPerturbationDestroy

end module Inversion_Perturbation_class
